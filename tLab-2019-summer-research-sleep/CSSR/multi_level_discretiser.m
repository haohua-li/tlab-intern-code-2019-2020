function [alphabet, outData] = multi_level_discretiser(inData, n)
% ________________________________________________________________
% multi_level_discretiser 
%   To equally divide the range of inData into n sub-ranges. 
%   Then correspond each sub-range to a unique character.
% 
% ---INPUTS:
%   inData, a MxN matrix of a group of time series. Assume the each row is 
%            an independent time series.
%   n,      the number of characters. (n <= 26)
%                                   
% ---OUPUTS:
%   alphabet, the set of all characters that appear in the symbolised
%             sequence.
%   outData, a string of discrete symbols. (e.g. ABBCDE...)   
% ----------------------------------------------------------------
% This function is written by Haohua Li, 2020. 
% Visit my github <https://github.com/randoruf>
% ----------------------------------------------------------------
% This function is free software: you can redistribute it and/or modify it under
% the terms of the GNU General Public License as published by the Free Software
% Foundation, either version 3 of the License, or (at your option) any later
% version.
%
% This program is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
% FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
% details.
%
% You should have received a copy of the GNU General Public License along with
% this program. If not, see <http://www.gnu.org/licenses/>.
% ________________________________________________________________

% if user pass wrong inputs.....
if nargin == 1 
    n = 4;  
end 

% make sure inData is a 1 dimensional time series 
if size(inData, 1) ~= 1 
    error('Input data must be a 1-dimensional vector!')
end
% make sure n is an integer 
if n - round(n) ~= 0 
    error('The number of characters must be an integer. ')
end
% if there are too many levels 
% if n = 2, this algorithm happens to be median binarisation.
if n > 6 || n < 2
    error('For best performance, the maximum number of characters should be less than 6 (but you could specify it in "multi_level_discretiser.m" ).')
end 

% p is an array of percentages that used for partition.
sub_range = 100/n; 
p = (1:n-1)*sub_range;

% P is percentiles of p. 
P = prctile(inData,p); 

% rule out bad cases 
%    - if there are duplicate elements in the output array, it means 
%      the input time series may be too short or the number of characters
%      used may be too many. 
for i = 1:length(P)-1
    % Make sure that the differences between levels are significant!
    if P(i) - P(i+1) == 0
        error('Percentile array generated by MATLAB may be not accurate. Please try to reduce the number of characters or use a longer time series. ')
    end
end 


% %% For Testing 
% subplot(1, 2, 1)
% % A part from the input data 
% plot(1:50, inData(1:50))
% title('An arbitrary normal distribution')
% xlabel('byte/point')
% ylabel('Amplitude')
% for i = 1:n-1 
%     yline(P(i), '--r', num2str(p(i)));
% end 
% subplot(1, 2, 2)
% % Histogram with a Normal Distribution Fit
% histogram(inData)
% title('Histogram of an arbitrary normal distribution')
% xlabel('Amplitude')
% ylabel('Count') 
% for i = 1:n-1 
%     xline(P(i), '--r', num2str(p(i)));
% end 


%% Generating output string 
% maximum alphabet used in the discretisation of inData.  
alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

% pre-allocate memory space for output string. 
outData = blanks(length(inData));

% loop through the whole input data series. 
for i = 1:length(inData)
    % define the symbol of the current value 
    for j = 1:length(P)
        % find the first level that is greater than current value. 
        if inData(i) <= P(j)
            outData(i) = alphabet(j); 
            break; 
        % if the current value is located at the last sub-range...
        elseif inData(i) > P(end)
            outData(i) = alphabet(n);  
            break;
        % proceed to next level 
        else 
            continue; 
        end
    end
end 

% truncate the full alphabet if necessary.
alphabet = alphabet(1:n); 

end 